#include "Contig.h"
#include "Match.h"
#include "approximation.cpp"
#include "Parser.hpp"
#include <memory>


using namespace std;



tuple<bool,bool,array<string, 5>> treatProgrammeEntry(int argc, char * argv[])
{
  int opt;
  bool generate_matches=false;
  bool every_pair=false;
  array<string, 5> optionsValues = {"-1","-1","output.fasta","output.cons", "results"};

  while((opt = getopt(argc, argv, ":hpco:r:f:m:d:")) !=-1) {
      switch (opt)
	{
	case 'f':
	  optionsValues[0]=optarg;
	  break;
	case 'm':
	  optionsValues[1]=optarg;
	  break;
	case 'r':
	  optionsValues[2]=optarg;
	  break;
       	case 'o': 
	  optionsValues[3]=optarg;
	  break;
	case 'd': 
	  optionsValues[4]=optarg;
	  break;
	case 'c':
	  generate_matches=true;
	  break;
	case 'p':
	  every_pair=true;
	  break;
	case 'h':
	default:
	  cout << "Available options:\n";
	  cout << "-o output .cons file name (default output.cons)\n";
	  cout << "-r result fasta file (default output.fasta)\n";
	  cout << "-f fasta directory\n";
	  cout << "-m match directory: ";
	  cout << "Input files must be generated by blastn using the command: \n";
	  cout << "\t blastn -task megablast -query file1.fasta -subject file2.fasta -ungapped -out inputFileName -outfmt \"6 score qseqid qstart qend qlen sseqid sstart send slen\"";
	  cout << "-c generates matches files with blastn";
	  cout << "-p merge every pair of fasta files";
	  cout << "-d output directory for option -p (default results)";
	  cout << endl;
	  exit(EXIT_SUCCESS);
	  break;
	}
  }
  if(optionsValues[0]=="-1") {
      cout << "Error, fasta directory not provided\n";
      exit(EXIT_FAILURE);
  }
  if(optionsValues[1]=="-1") {
    cout << "Error, match directory not provided\n";
    exit(EXIT_FAILURE);
  }

  return make_tuple(generate_matches,every_pair,optionsValues);
}


AssemblySet copy_pair(AssemblySet & assembly_set, unsigned id1, unsigned id2)
{
  AssemblySet tmp;
  for(auto &c : assembly_set[id1])
    tmp[id1].insert(make_unique<Contig>(*c.get()));
  for(auto &c : assembly_set[id2])
    tmp[id2].insert(make_unique<Contig>(*c.get()));

  return tmp;
}


int main(int argc, char *argv[])
{

  AssemblySet assembly_sets;
  MatchMatrix matches;

  map<string,unsigned> ids;

  auto options = treatProgrammeEntry(argc, argv);
  // tuple<bool,bool,array<string, 4>> options;
  // get<0>(options)=false;
  // get<1>(options)=true;
  // get<2>(options)= {"Data/Real/escherichia/contigs","Data/Real/escherichia/matches","output.fasta","output.cons"};

  
  treatFastaDirectory(get<2>(options)[0].c_str(), assembly_sets, ids,get<1>(options));
  if(get<0>(options))
    createMatchDirectory(get<2>(options)[1].c_str(), get<2>(options)[0].c_str(), ids);
  

  std::cout << "Consensus construction" << std::endl;

  if(get<1>(options)){
    for(auto &p : ids){
      for(auto &p2 : ids){
	if(p2.second<=p.second) continue;
	AssemblySet a_s;
	string tmp = get<2>(options)[0];
	tmp.append("/");
	tmp.append(p.first);
	tmp.append(".fasta");
	parseFastaFile(tmp.c_str(), 0, a_s);

	tmp = get<2>(options)[0];
	tmp.append("/");
	tmp.append(p2.first);
	tmp.append(".fasta");
	parseFastaFile(tmp.c_str(), 1, a_s);

	map<string,unsigned> ids_tmp;
	ids_tmp[p.first]=0;
	ids_tmp[p2.first]=1;

	MatchMatrix m;
	treatMatchDirectory(get<2>(options)[1].c_str(), a_s, ids_tmp, m,false);

	
	merge_algorithm(a_s, m, ids_tmp);
	tmp = get<2>(options)[4];
	tmp.append("/");
	tmp.append(p.first);
	tmp.append("!");
	tmp.append(p2.first);

	string output = tmp;
	output.append(".fasta");
	output_contig(output.c_str(), a_s);

	output = tmp;
	output.append(".cons");
	output_contig_ordering(output.c_str(), a_s,ids_tmp);
	
      }
    }
  }else {
    treatMatchDirectory(get<2>(options)[1].c_str(), assembly_sets, ids, matches);
    merge_algorithm(assembly_sets,matches,ids);

    output_contig(get<2>(options)[2].c_str(),assembly_sets);
    output_contig_ordering(get<2>(options)[3].c_str(),assembly_sets, ids);
  }
  return 0;
}

